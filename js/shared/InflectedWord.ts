"use strict";

import Word from './Word'
import UnstudiedWord from './UnstudiedWord'
import Inflection from './Inflection'
import Inflections from './Inflections'

/**
 * An inflection of a word generated by Inflection. The facts assumed to be required to know it are a grammar rule
 * defining how to inflect the form (e.g. by adding an ending) and the base form.
 */
export default class InflectedWord extends Word {
    inflection: Inflection
    stem: string
    inflectionByForm : { [s: string]: InflectedWord } = {}
    
    /**
     * @param infinitive Word representing the base form. null if this IS the infinitive.
     */
    constructor(public jp: string, public infinitive: InflectedWord, public form: string) {
        super(jp, '');

        this.infinitive = infinitive || this
        this.form = form
        this.en = {}
    }

    setForm(form) {
        this.form = form
    }

    /**
     * The knowledge required for an inflection is the base form of the word as well as any gramar rules used to
     * derive it.
     */
    visitFacts(visitor: (Fact) => any) {
        this.visitRequired(visitor)

        visitor(this.inflection.getFact(this.form))
        visitor(this.infinitive)
    }

    clone(word: InflectedWord) {
        this.inflection = word.inflection
        this.infinitive = word.infinitive
        this.stem = word.stem
        this.jp = word.jp
        this.en = word.en
    }

    changeInflection(inflection: Inflection) {
        let defaultEnding = inflection.getEnding(inflection.defaultForm)
        
        if (this.jp.substr(this.jp.length - defaultEnding.length) != defaultEnding) {
            throw new Error(`Expected ${this.jp} to end in ${defaultEnding}`)
        }
        
        let stem = this.jp.substr(0, this.jp.length - defaultEnding.length)
        
        this.stem = stem
        this.inflection = inflection

        for (let inflectedWord of this.inflection.inflectAll(this.infinitive, this.stem, false, {})) {
            if (this.inflectionByForm[inflectedWord.form]) {
                this.inflectionByForm[inflectedWord.form].clone(inflectedWord)
            }
        }
    }

    setInflection(inflection: Inflection) {
        this.inflection = inflection

        let expectedEnding = inflection.getEnding(this.form)
        let actualEnding = this.jp.substr(this.jp.length - expectedEnding.length)

        if (this.infinitive == this && (actualEnding != expectedEnding)) {
            throw new Error(`Expected ${this.jp} to end with ${expectedEnding}, not ${actualEnding}`)
        }

        this.stem = this.jp.substr(0, this.jp.length - expectedEnding.length)

        return this
    }

    inflect(form: string) {
        let result
        
        if (form == this.form) {
            result = this
        }
        else {
            // maintain object identity to make things easier when changing inflection
            result = this.inflectionByForm[form]

            if (!result) {
                result = this.inflection.inflect(this.infinitive, this.stem, form)

                this.inflectionByForm[form] = result
            }
        }

        return result
    }

    visitAllInflections(visitor: (InflectedWord) => any, excludeInherited: boolean) {
        if (!this.inflection) {
            throw new Error(this + ' is an inflected word without inflection.')
        }

        for (let form of this.inflection.getAllForms()) {
            visitor(this.inflect(form))
        }
    }

    toFormString(useInfinitive) {
        return (useInfinitive ? this.infinitive : this).toString() + '@' + this.form
    }

    getId() {
        return (this.infinitive === this ? 
            super.getId() : this.infinitive.toString()) + '@' + this.form
    }

    getJsonType() {
        return 'inflected'
    }

    static fromJson(json, inflections: Inflections): UnstudiedWord {
        if (json.type == 'inflected') {
            return new InflectedWord(json.target, null, json.form)
                .setEnglish(json.en)
                .setInflection(inflections.get(json.inflection))
        }
        else {
            return super.fromJson(json, inflections)
        }
    }

    toJson() {
        return {
            target: this.jp,
            en: this.en[''],
            form: this.form,
            inflection: (this.inflection ? this.inflection.id : undefined),
            type: this.getJsonType()
        }
    }
}