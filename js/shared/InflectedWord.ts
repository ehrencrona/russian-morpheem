"use strict";

import Word from './Word'
import UnstudiedWord from './UnstudiedWord'
import Inflection from './Inflection'
import Inflections from './Inflections'

/**
 * An inflection of a word generated by Inflection. The facts assumed to be required to know it are a grammar rule
 * defining how to inflect the form (e.g. by adding an ending) and the base form.
 */
export default class InflectedWord extends Word {
    inflection: Inflection
    stem: string
    inflectionByForm : { [s: string]: InflectedWord } = {}

    // ugly hack. remove
    originalJp: string

    /**
     * @param infinitive Word representing the base form. null if this IS the infinitive.
     */
    constructor(public jp: string, public infinitive: InflectedWord, public form: string) {
        super(jp, '');

        // ugly hack. remove
        this.originalJp = jp

        this.infinitive = infinitive || this
        this.form = form
        this.en = {}
    }

    setForm(form) {
        this.form = form
    }

    /**
     * The knowledge required for an inflection is the base form of the word as well as any gramar rules used to
     * derive it.
     */
    visitFacts(visitor: (Fact) => any) {
        this.visitRequired(visitor)

        visitor(this.inflection.getFact(this.form))
        visitor(this.infinitive)
    }

    clone(word: InflectedWord) {
        this.inflection = word.inflection
        this.infinitive = word.infinitive
        this.stem = word.stem
        this.jp = word.jp
        this.en = word.en
    }

    changeInflection(inflection: Inflection) {
        this.setInflection(inflection)

        for (let inflectedWord of this.inflection.inflectAll(this.infinitive, false, {})) {
            if (this.inflectionByForm[inflectedWord.form]) {
                this.inflectionByForm[inflectedWord.form].clone(inflectedWord)
            }
        }
    }

    setInflection(inflection: Inflection) {
        this.inflection = inflection

        let expectedEnding = inflection.getEnding(this.form)

        let jp = this.originalJp

        if (expectedEnding[0] == '<') {
            expectedEnding = expectedEnding.substr(1)

            let actualEnding = jp.substr(jp.length - expectedEnding.length)

            if (actualEnding != expectedEnding) {
                throw new Error(`Expected ${jp} to end with ${expectedEnding}, not ${actualEnding}`)
            }

            this.stem = jp.substr(0, jp.length - expectedEnding.length)
            
            if (this.stem[this.stem.length-1] == '<') {
                this.stem = this.stem.substr(0, this.stem.length-1)
            }
            else {
                this.stem += '>'
            }
        }
        else {
            let actualEnding = jp.substr(jp.length - expectedEnding.length)

            if (actualEnding != expectedEnding) {
                throw new Error(`Expected ${jp} to end with ${expectedEnding}, not ${actualEnding}`)
            }

            this.stem = jp.substr(0, jp.length - expectedEnding.length)
        }

        this.jp = this.inflection.getInflectedForm(this, this.form)

        return this
    }

    inflect(form: string) {
        if (this.infinitive != this) {
            return this.infinitive.inflect(form)
        }

        if (this.stem[this.stem.length-1] == '>') {
            throw new Error('cannot inflect inflected form')
        }

        let result
                
        if (form == this.form) {
            result = this
        }
        else {
            // maintain object identity to make things easier when changing inflection
            result = this.inflectionByForm[form]

            if (!result) {
                result = this.inflection.inflect(this.infinitive, form)

                this.inflectionByForm[form] = result
            }
        }

        return result
    }

    visitAllInflections(visitor: (InflectedWord) => any, excludeInherited: boolean) {
        if (this.infinitive != this) {
            return this.infinitive.visitAllInflections(visitor, excludeInherited)
        }

        if (!this.inflection) {
            throw new Error(this + ' is an inflected word without inflection.')
        }

        for (let form of this.inflection.getAllForms()) {
            visitor(this.inflect(form))
        }
    }

    toFormString(useInfinitive) {
        return (useInfinitive ? this.infinitive : this).toString() + '@' + this.form
    }

    getId() {
        return (this.infinitive === this ? 
            super.getId() : this.infinitive.toString()) + '@' + this.form
    }

    getJsonType() {
        return 'inflected'
    }

    static fromJson(json, inflections: Inflections): UnstudiedWord {
        if (json.type == 'inflected') {
            let inflection = inflections.get(json.inflection)
            
            if (!inflection) {
                throw new Error('The inflectedion ' + json.inflection + ' does not exist.')
            }
            
            return new InflectedWord(json.target, null, json.form)
                .setEnglish(json.en)
                .setInflection(inflection)
        }
        else {
            return super.fromJson(json, inflections)
        }
    }

    toJson() {
        return {
            target: this.originalJp,
            en: this.en[''],
            form: this.form,
            inflection: (this.inflection ? this.inflection.id : undefined),
            type: this.getJsonType()
        }
    }
}