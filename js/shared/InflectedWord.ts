"use strict";

import Word from './Word'
import UnstudiedWord from './UnstudiedWord'
import Inflection from './Inflection'
import Inflections from './Inflections'

/**
 * An inflection of a word generated by Inflection. The facts assumed to be required to know it are a grammar rule
 * defining how to inflect the form (e.g. by adding an ending) and the base form.
 */
export default class InflectedWord extends Word {
    inflection: Inflection
    
    /**
     * @param infinitive Word representing the base form. null if this IS the infinitive.
     */
    constructor(public jp, public stem, public infinitive: InflectedWord, public form) {
        super(jp, '');
        
        if (!infinitive && jp.substr(0, stem.length) != stem) {
            throw new Error(`Expected ${jp} to start with ${stem}`)
        }
        
        this.stem = stem
        this.infinitive = infinitive || this
        this.form = form
        this.en = {}
        
    }

    setForm(form) {
        this.form = form
    }

    /**
     * The knowledge required for an inflection is the base form of the word as well as any gramar rules used to
     * derive it.
     */
    visitFacts(visitor: (Fact) => any) {
        this.visitRequired(visitor)

        visitor(this.inflection.getFact(this.form))
        visitor(this.infinitive)
    }

    setInflection(inflection: Inflection) {
        this.inflection = inflection

        if (this.infinitive == this && (this.jp.substr(this.stem.length) != inflection.getEnding(this.form))) {
            throw new Error(`Expected ${this.jp} to end with ${inflection.getEnding(this.form)}`)
        }

        return this
    }

    inflect(form: string) {
        return this.inflection.inflect(this.infinitive, this.stem, form)
    }

    visitAllInflections(visitor: (InflectedWord) => any, excludeInherited: boolean) {
        if (!this.inflection) {
            throw new Error(this + ' is an inflected word without inflection.')
        }
        
        for (let inflectedWord of this.inflection.inflectAll(this.infinitive, this.stem, excludeInherited, {})) {
            visitor(inflectedWord)
        }
    }

    toFormString(useInfinitive) {
        return (useInfinitive ? this.infinitive : this).toString() + '@' + this.form
    }

    getId() {
        return (this.infinitive === this ? 
            super.getId() : this.infinitive.toString()) + '@' + this.form
    }

    getJsonType() {
        return 'inflected'
    }

    static fromJson(json, inflections: Inflections): UnstudiedWord {
        if (json.type == 'inflected') {
            return new InflectedWord(json.target, json.stem, null, json.form)
                .setEnglish(json.en)
                .setInflection(inflections.get(json.inflection))
        }
        else {
            return super.fromJson(json, inflections)
        }
    }

    toJson() {
        return {
            target: this.jp,
            en: this.en[''],
            stem: this.stem,
            form: this.form,
            inflection: (this.inflection ? this.inflection.id : undefined),
            type: this.getJsonType()
        }
    }
}